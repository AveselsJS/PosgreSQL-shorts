# Выжимка по работе с PosgreSQL

Попалась мне книжка по PostgreSQL и насчитывала она 1100 страниц, поэтому было принято решение сделать выжимку по самым необходимым элементам. Ясное дело, что есть документация, но порой по избитым вопросам сделав выписку в одном месте быстро находишь то, что нужно не вынуждая себя гуглить запрос.

## Оглавление
- [Выжимка по работе с PosgreSQL](#выжимка-по-работе-с-posgresql)
  - [Оглавление](#оглавление)
  - [Основные типы данных](#основные-типы-данных)
  - [Операторы условий и предикты](#операторы-условий-и-предикты)
  - [Простые запросы SELECT](#простые-запросы-select)
    - [Подробно о фильтре LIKE](#подробно-о-фильтре-like)
  - [Cоединения JOIN](#cоединения-join)
    - [INNER JOIN](#inner-join)
    - [RIGHT OUTHER JOIN](#right-outher-join)
    - [LEFT OUTHER JOIN](#left-outher-join)
    - [FULL OUTHER JOIN](#full-outher-join)
    - [CROSS JOIN](#cross-join)
  - [Подзапросы](#подзапросы)
  - [Data Definition Language](#data-definition-language)
    - [Primary key (Первичные ключи)](#primary-key-первичные-ключи)
    - [Foreign key (Внешние ключи)](#foreign-key-внешние-ключи)
    - [Ограничения-проверки CHECK](#ограничения-проверки-check)
    - [Значение по умолчанию DEFAULT](#значение-по-умолчанию-default)
    - [Последовательности Sequences](#последовательности-sequences)
    - [Нормализация](#нормализация)
    - [CRUD oперации](#crud-oперации)
      - [INSERT — добавить строки в таблицу](#insert--добавить-строки-в-таблицу)
      - [UPDATE — изменить строки таблицы](#update--изменить-строки-таблицы)
      - [DELETE — удалить записи таблицы](#delete--удалить-записи-таблицы)
      - [RETURNING - получить модифицированные данные в процессе их обработки](#returning---получить-модифицированные-данные-в-процессе-их-обработки)
  - [Представления Views](#представления-views)

## Основные типы данных

| Тип данных | Название | Байты | Описание | Размерность |
| :--------: | :------: | :---: | :------- | :---------- |
| Целые числа | smallserial | 2 | Автоувеличение. Малые числа | 1 - 32.367 |
| Целые числа | serial | 4 | Автоувеличение. Средние числа | 1 - 2.147.483.648 |
| Целые числа | bigserial | 8 | Автоувеличение. Большие числа | 1 - 9.223.372.036.854.775.807 |
| Целые числа | smallint | 2 | Малые числа | 2^16 -> -32.768 - 32.767 |
| Целые числа | integer | 4 | Средние числа | 2^32 -> -2.147.483.648 - 2.147.483.647 |
| Целые числа | bigint | 8 | Большие числа | 2^64 -> -9.223.372.036.854.775.808 - 9.223.372.036.854.775.807 |
| Реальные числа | decimal / numeric | Переменная | Указанная пользователем точность | -3.4 * 10^38 - +3.4 * 10^38 |
| Реальные числа | real / float | 4 | Указанная пользователем точность | 6 цифр после запятой | 
| Реальные числа | double precision / float8 / float | 8 | Указанная пользователем точность | 15 цифр после запятой |
| Cимволы | char | Переменная | Фиксированя длина символьной длины | Фиксирует пространство под определенное количество символов |
| Cимволы | varchar | Переменная | Фиксированя длина символьной длины | Фиксирует пространство исходя из количества символов |
| Cимволы | text | Переменная | Произвольная длина символьной длины | Фиксирует пространство исходя из количества символов |
| Логический | boolean / bool | 1 | Используется логика | True / False |
| Время | date | 4 | Хранит только дату | 4713 В.С. -> 294.276 AD |
| Время | time | 8 | Хранит только дату | 00:00:00 -> 24:00:00 |
| Время | timestamp | 8 | Хранит дату и время | 4713 В.С. -> 294.276 AD |
| Время | interval | 16 | Cохраняет разницу между двумя временными промежутками | -178.000.000 -> + 178.000.000 |
| Время | timestamptz | 8 | Cохраняет временной промежуток и временную зону | 4713 В.С. -> 294.276 AD + tz |

Также другими типами, которые часто используются и могут быть использованы в PosgreSQL являются:
- Arrays (Массивы)
- JSON (JavaScript ориентированный объект)
- XML
- NULL - отсутствие данных

## Операторы условий и предикты
PosrgreSQL поддерживает следующие операторы условий:
| Оператор условий | Описание |
| :--------------: | :------- |
| < | строго меньше |
| > | строго больше |
| <= | меньше или равно |
| >= | больше или равно |
| = | равно |
| <> или != | не равно |

PostgreSQL поддерживает следующие предикты: 
| Оператор условий | Описание |
| :--------------: | :------- |
| IS NULL | cодержание значений NULL. Уточнение: NULL это неопределённость, а не значение NULL как в JS |
| IS NOT NULL | отсутствует ли значение NULL |
| IS TRUE | cодержание значений TRUE |
| IS NOT TRUE | отсутствует ли значение TRUE |
| IS FALSE | cодержание значений FALSE |
| IS NOT FALSE | отсутствует ли значение FALSE |
| IS UNKNOWN | cодержание значений NULL |
| IS NOT UNKNOWN | отсутствует ли значение UNKNOWN |

## Простые запросы SELECT
SELECT запросы это основа РostgreSQL в случае фильтрации и создании результирующих наборов из базы данных. В SELECT активно используются операторы условий для дополнительной филтрации необходимых строк. 

| Параметр | Пояснение | Синтаксис | Порядок следования | Примеры | 
| :------: | :-------- | :-------- | :----------------- | :--------------- |
| SELECT | Выбирает необходимые колонки | SELECT <column_name> | Первым в каждом запросе | - | 
| FROM | Указывается таблица из которой выбирать данные | FROM <table_name> | После SELECT | - |
| DISTINCT | Убирает повторяющиеся строки | SELECT DISTINCT (<colemn_name>) | После SELECT | [01_distinct.sql](01_simple_queries_with_select/01_distinct.sql) |
| COUNT | Возвращает количество строк | SELECT COUNT (<colemn_name>) | После SELECT | [02_count.sql](01_simple_queries_with_select/02_count.sql) |
| WHERE | Возвращает строки, которые проходят условие указанное в WHERE | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <condition_name> | После FROM | [03_where.sql](01_simple_queries_with_select/03_where.sql) |
| AND | Создаёт несколько условий в WHERE, чтобы в результирующий набор попали значения проходящие несколько условий | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <condition_name_1> AND <condition_name_n> | После WHERE | [04_and_ur.sql](01_simple_queries_with_select/04_and_or.sql) |
| OR| Создаёт несколько условий в WHERE, чтобы в результирующий набор попали значения проходящие под одно из условий | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <condition_name_1> OR <condition_name_n> | После WHERE | [04_and_ur.sql](01_simple_queries_with_select/04_and_or.sql) |
| BETWEEN | Создаёт диапазон которые отфильтровывает результирующий набор. Включает границы. Подобный фильтр может быть создан и с помощью AND | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <column_name> BETWEEN <condition_name_1> AND <condition_name_2> | После WHERE | [05_between.sql](01_simple_queries_with_select/05_between.sql) |
| IN | Является более удобным аналогом OR в случае, когда условий много. Подобный фильтр может быть создан и с помощью OR | WHERE <column_name> IN (<condition_name_1>, <condition_name_2>, <condition_name_n> | После WHERE | [06_in_not_in.sql](01_simple_queries_with_select/06_in_not_in.sql) |
| NOT IN | В результирующий набор попадают все строки, которые не подпадают под фильтр. Является противоположностью IN | WHERE <column_name> NOT IN (<condition_name_1>, <condition_name_2>, <condition_name_n> | После WHERE | [06_in_not_in.sql](01_simple_queries_with_select/06_in_not_in.sql) |
| ORDER BY | Сортирует результирующий набор по убыванию или по возрастанию. По умолчанию сортирует по возрастанию | SELECT <column_name> FROM <table_name> ORDER BY <column_name> | Когда необходимо результирующий набор соответствующе отсортировать. Может быть как перед LIMIT так и после определенного WHERE | [07_order_by.sql](01_simple_queries_with_select/07_order_by.sql) |
| MIN | Находит минимальное или самую раннюю строку исходя из условия запроса | SELECT MIN (<column_name>) | После SELECT | [08_min_max_avg.sql](01_simple_queries_with_select/08_min_max_avg.sql) |
| MAX | Находит максимальное или самую позднюю строку исходя из условия запроса | SELECT MAX (<column_name>) | После SELECT | [08_min_max_avg.sql](01_simple_queries_with_select/08_min_max_avg.sql) |
| AVG | Находит среднее значение строки исходя из условия запроса | SELECT AVG (<column_name>) | После SELECT | [08_min_max_avg.sql](01_simple_queries_with_select/08_min_max_avg.sql) |
| LIKE | Лёгкая версия регулярных выражений. После LIKE задаётся шаблон, который служит фильтров | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <column_name> <br/> LIKE <like_string> | После WHERE | [09_like.sql](01_simple_queries_with_select/09_like.sql) |
| LIMIT | Ограничивает количество строк в результирующем наборе | SELECT <column_name> <br/> FROM <table_name> <br/> LIMIT <limit_number> | Вконце запроса | [10_limit.sql](01_simple_queries_with_select/10_limit.sql) |
| IS NULL | Выбираются пустые строки, которые находятся в указанном столбце в условии поиска | SELECT <column_name> <br/> FROM <table_name>  <br/> WHERE <column_name> IS NULL | После WHERE на необходимый столбец | [11_check_on_null.sql](01_simple_queries_with_select/11_check_on_null.sql) |
| IS NOT NULL | Выбираются все не пустые строки, которые находятся в указанном столбце в условии поиска | SELECT <column_name> <br/> FROM <table_name>  <br/> WHERE <column_name> IS NOT NULL | После WHERE на необходимый столбец | [11_check_on_null.sql](01_simple_queries_with_select/11_check_on_null.sql) |
| GROUP BY | Группирует данные по значениям из указанного столбца | SELECT <column_name>, SUM(<column_name>) <br/>  FROM <table_name> <br/>  GROUP BY <column_name> <br/>  ORDER BY SUM(<column_name>) DESC | В месте, где необходима группировка | [12_group_by](01_simple_queries_with_select/12_group_by.sql) |
| HAVING | Вторичный фильтр, когда WHERE - первичный фильтр. Используется, когда нужно допольнительно отфилтровать результат после работы WHERE | SELECT <column_name> (<column_name> * <column_name>) FROM <table_name> WHERE <condition_name>  GROUP BY <column_name> HAVING SUM(<column_name> * <column_name>)  <condition_name> | [13_having.sql](01_simple_queries_with_select/13_having.sql) |
| UNION | Объеденяет уникальные строки из общих столбцов разных таблиц | SELECT <column_name> <br/> FROM <table_name_1> UNION SELECT <column_name> <br/> FROM <table_name_2> | Между двумя запросами | [14_union_intersect_except.sql](01_simple_queries_with_select/14_union_intersect_except.sql) |
| UNION ALL | Объеденяет абсолютно все строки из общих столбцов разных таблиц | SELECT <column_name> <br/> FROM <table_name_1> UNION ALL SELECT <column_name> <br/> FROM <table_name_2> | Между двумя запросами | [14_union_intersect_except.sql](01_simple_queries_with_select/14_union_intersect_except.sql) |
| INTERSECT | Выводит пересекающиеся уникальные строки из общих столбцов разных таблиц | SELECT <column_name> <br/> FROM <table_name_1> INTERSECT SELECT <column_name> <br/> FROM <table_name_2> | Между двумя запросами | [14_union_intersect_except.sql](01_simple_queries_with_select/14_union_intersect_except.sql) |
| INTERSECT ALL | Выводит пересекающиеся абсолютно все строки из общих столбцов разных таблиц | SELECT <column_name> <br/> FROM <table_name_1> INTERSECT ALL SELECT <column_name> <br/> FROM <table_name_2> | Между двумя запросами | [14_union_intersect_except.sql](01_simple_queries_with_select/14_union_intersect_except.sql) |
| EXCEPT | Выводит не пересекающиеся уникальные строки из общих столбцов разных таблиц | SELECT <column_name> <br/> FROM <table_name_1> EXCEPT SELECT <column_name> <br/> FROM <table_name_2> | Между двумя запросами | [14_union_intersect_except.sql](01_simple_queries_with_select/14_union_intersect_except.sql) |
| EXCEPT ALL | Выводит не пересекающиеся абсолютно все строки из общих столбцов разных таблиц | SELECT <column_name> <br/> FROM <table_name_1> EXCEPT ALL SELECT <column_name> <br/> FROM <table_name_2> | Между двумя запросами | [14_union_intersect_except.sql](01_simple_queries_with_select/14_union_intersect_except.sql) |


### Подробно о фильтре LIKE
Фильтр LIKE используется для того, чтобы искать строки похожие на заданный шаблон. <br/>
**Плейсхордеры:** <br/>
- `%` - означающий 0, 1 или более символов. <br/>
- `_` (нижнее подчеркивание) означает ровно 1 любой символ. <br/> <br/>

**Использование:** <br/>
- LIKE `U%` - все выражение начинающиеся с U. 
- LIKE `%a` - все выражение заканчивающееся на а.
- LIKE `%гусь%` - все строки, где есть словарный набор - гусь. 
- LIKE `J%n` - все строки, которые начинаются на J и кончаются на n. 
- LIKE `_oh_` - все строки имеющие ровно один символ до и ровно один символ после oh. 
- LIKE `_oh%` - все строки где ровно один символ находится перед oh и произвольное количество символов после oh.
  
## Cоединения JOIN 

В PostgreSQL существуют следующие типы JOIN'ов:
- INNER JOIN
- LEFT JOIN
- RIGHT JOIN 
- LEFT OUTHER JOIN
- FULL OUTHER JOIN 
- CROSS JOIN

При создании соединений правой табличкой считается **первая** табличка, а **вторая** табличка - левой.

### INNER JOIN
Внутреннее соединение. <br/> 
При проведение такого соединения из второй (левой) таблички в первую (правую) табличку попадут только те строки, внешних ID ключ которых соответствует второй (левой) табличке.

Пример реализации: <br/> 

[![msg297304287-433128.jpg](https://i.postimg.cc/MTVPWMyR/msg297304287-433128.jpg)](https://postimg.cc/0M5dnNX2)

Примеры кода: [01_inner_join.sql](02_joins/01_inner_join.sql)

### RIGHT OUTHER JOIN
Внешнее правое соединение. <br/>
При проведении правого внешнее соединение из первой (правой) таблицы попадают абсолютно все выбранные записи, а если к этим записям из второй (левой) таблички есть соответствия, то они подтягиваются, если нет, тогда результатом будет NULL.

Пример реализации: <br/> 

[![msg297304287-433129.jpg](https://i.postimg.cc/xdkp4F86/msg297304287-433129.jpg)](https://postimg.cc/KK25KfnT)

Примеры кода: [02_left_right_join](02_joins/02_left_right_join.sql)

### LEFT OUTHER JOIN

Внешнее левое соединение. <br/>
При проведении левое внешнее соединение из второй (левой) таблицы попадают абсолютно все выбранные записи, а если к этим записям из первой (правой) таблички есть соответствия, то они подтягиваются, если нет, тогда результатом будет NULL.

Пример реализации: <br/> 

[![msg297304287-433130.jpg](https://i.postimg.cc/rFXTCxn6/msg297304287-433130.jpg)](https://postimg.cc/CdN9wBpJ)

Примеры кода: [02_left_right_join](02_joins/02_left_right_join.sql)

### FULL OUTHER JOIN
Полное внешнее соединение. <br/>
При проведении полного внешнего соединения, забираются полностью все выбранные данные из обоих таблиц, если есть соответствия по ключам между табличками, то они подтягиваются, если их нет, тогда результатом будет NULL

Пример реализации: <br/> 

[![msg297304287-433131.jpg](https://i.postimg.cc/wvnprm9m/msg297304287-433131.jpg)](https://postimg.cc/9RPKRzRm)

### CROSS JOIN
Декартовое произведение. <br/>
При проведении декартового произведения, сопоставляются все записи из одной таблички к другой. Таким образом к каждом записи будет соответствующий перебор всех записей из другой таблички. Если есть общие данные из табличек, они подтягиваются, если их нет, тогда результатом будет NULL.

Пример реализации: <br/> 

[![msg297304287-433132.jpg](https://i.postimg.cc/8zLV05YF/msg297304287-433132.jpg)](https://postimg.cc/18RTg9sP)

## Подзапросы
Подзапросы необходимы когда перед тем как отфильтровать данные основным запросом, необходимо сформировать результирующий выбор ещё одним запросом (он и является подзапросом).

| Подзапрос | Описание | Синтаксис | Примеры |
| :-------: | :------- | :-------- | :------ |
| EXISTS | Аргументом EXISTS является обычный оператор SELECT, т. е. подзапрос. Возвращает все строки, которые попадают в результирующий набор | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE EXISTS (SELECT <column_name> FROM <table_name>...) | [01_where_exists.sql](03_underqueries/01_where_exists.sql) |
| NOT EXISTS | Аргументом EXISTS является обычный оператор SELECT, т. е. подзапрос. Возвращает все строки, которые НЕ попадают в результирующий набор  | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE NOT EXISTS (SELECT <column_name> FROM <table_name>...) | [01_where_exists.sql](03_underqueries/01_where_exists.sql) |
| ANY / SOME | В основное условие попадают весь результирующий набор подзапроса | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <column_name> ANY (SELECT <column_name> FROM <table_name>...) | [02_any_all.sql](03_underqueries/02_any_all.sql) |
| ALL | В основное условие попадают лишь те результаты подзапроса, которые выполняют условие указанного в основном запросе | SELECT <column_name> <br/> FROM <table_name> <br/> WHERE <conditional> ALL (SELECT <column_name> FROM <table_name>...) | [02_any_all.sql](03_underqueries/02_any_all.sql) |

## Data Definition Language 
Data Definition Language - это группа операторов определения данных. Другими словами, с помощью операторов, входящих в эту группы, мы определяем структуру базы данных и работаем с объектами этой базы, т.е. создаем, изменяем и удаляем их. В эту группу входят следующие операторы: <br/>
- CREATE - используется для создания объектов базы данных.
- ALTER - используется для изменения объектов базы данных.
- DROP - используется для удаления объектов базы данных.
- т.д.

### Primary key (Первичные ключи)
Первичные ключи - нужны для активного использования внешних и внутренних соединений и ещё для вытягивания данных по его ID. <br/> <br/>
Ограничение первичного ключа означает, что образующий его столбец или группа столбцов может быть уникальным идентификатором строк в таблице. Для этого требуется, чтобы значения были одновременно уникальными и отличными от NULL.
Эти запросы cоздания PRIMARY KEY равносильны:
```
CREATE TABLE products (
    product_id integer UNIQUE NOT NULL,
    name varchar(255),
    price integer,
    PRIMARY KEY (product_id)
)
```

```
CREATE TABLE products (
    product_id integer PRIMARY KEY,
    name varchar(255),
    price integer

)
```
При добавлении первичного ключа автоматически создаётся уникальный индекс.<br/>
Таблица может иметь максимум один первичный ключ (Ограничений уникальности и ограничений NOT NULL, которые функционально почти равнозначны первичным ключам, может быть сколько угодно, но назначить ограничением первичного ключа можно только одно). <br/><br/>

Лучше всего использовать синтаксис PRIMARY KEY, поскольку он в отличии от serial гарантирует, что мы не можем вставить дубликатили же NULL. <br/><br/>

Примеры запросов: [01_primary_key.sql](04_DDL/01_primary_key.sql)

### Foreign key (Внешние ключи)
Внешние ключи - нужны для активного использования внешних и внутренних соединений и ещё для вытягивания данных по его ID. <br/> <br/>
Ограничение внешнего ключа указывает, что значения столбца (или группы столбцов) должны соответствовать значениям в некоторой строке другой таблицы. Это называется ссылочной целостностью двух связанных таблиц.

Допустим мы хотим связать таблицу товаров (из пункта о первичных ключах) с новосозданной таблицей заказов: <br/>
```
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_id integer REFERENCES products (product_id),
    quantity integer
)
```
В такой схеме таблицу orders называют подчинённой таблицей, а products — главной. Соответственно, столбцы называют так же подчинённым и главным (или ссылающимся и целевым).
Предыдущую команду можно сократить так: <br/>
```
CREATE TABLE orders (
    order_id integer PRIMARY KEY,
    product_id integer REFERENCES products,
    quantity integer
)
```
то есть, если опустить список столбцов, внешний ключ будет неявно связан с первичным ключом главной таблицы. <br/>
Таблица может содержать несколько ограничений внешнего ключа. Это полезно для связи таблиц в отношении многие-ко-многим.  <br/>
Внешний ключ должен ссылаться на столбцы, образующие первичный ключ или ограничение уникальности. Таким образом, для связанных столбцов всегда будет существовать индекс (определённый соответствующим первичным ключом или ограничением), а значит проверки соответствия связанной строки будут выполняться эффективно. <br/> <br/>

Примеры запросов: [02_foreign_key](04_DDL/02_foreign_key.sql)

### Ограничения-проверки CHECK
Ограничение-проверка — наиболее общий тип ограничений. В его определении указывается, что значение данного столбца должно удовлетворять логическому выражению (проверке истинности).<br/> <br/>
Ограничение определяется после типа данных, как и значение по умолчанию. Значения по умолчанию и ограничения могут указываться в любом порядке. Ограничение-проверка состоит из ключевого слова CHECK, за которым идёт выражение в скобках. Это выражение должно включать столбец, для которого задаётся ограничение, иначе оно не имеет большого смысла. <br/> <br/>
Следует заметить, что ограничение-проверка удовлетворяется, если выражение принимает значение true или NULL. Так как результатом многих выражений с операндами NULL будет значение NULL, такие ограничения не будут препятствовать записи NULL в связанные столбцы. Чтобы гарантировать, что столбец не содержит значения NULL, можно использовать ограничение NOT NULL. <br/> <br/>

Примеры запросов: [03_check.sql](04_DDL/03_check.sql)

### Значение по умолчанию DEFAULT
Default используется обычно в колонках, которые являются не обязательными или например в колонках, где нужно значение по умолчанию, например фотография пользователя при новой регистрации в соц.сети. <br/> <br/>

Примеры запросов: [04_default.sql](04_DDL/04_default.sql)

### Последовательности Sequences 
CREATE SEQUENCE создаёт генератор последовательности. Эта операция включает создание и инициализацию специальной таблицы <table_name>, содержащей одну строку. Владельцем генератора будет пользователь, выполняющий эту команду. Если указано имя схемы, последовательность создаётся в заданной схеме, в противном случае — в текущей. Временные последовательности существуют в специальной схеме, так что при создании таких последовательностей имя схемы задать нельзя. <br/> <br/>

Примеры запросов: [05_sequences.sql](04_DDL/05_sequences.sql) и [06_sequences_tables.sql](04_DDL/06_sequences_tables.sql)

### Нормализация
Нормализация это процесс построение баз данных таким образом, чтобы данные поступающие в базу данных должны оформлятся в определённые сущности с конкретными ограничениями. <br/>Степень нормализации определяется нормальной формой. Существует всего 5 нормальных форм (далее НФ), но для более чем удовлетворительного результата достаточно 3НФ. <br/> <br/>

Первая номальная форма может быть назначена та база данных, которая выполняет следующие требования: <br/>
- не должно быть строк дубликатов.
- все атрибуты простых типов данных.
- все значения скалярные (одно значение простого типа данных в одном поле) 

Вторая номальная форма может быть назначена та база данных, которая выполняет следующие требования: <br/>
- Таблица удовлетворяет 1НФ
- Есть первичный ключ.
- Все атрибуты (поля) описывают первичный ключ целиком, а не лишь его часть.

Третья номальная форма может быть назначена та база данных, которая выполняет следующие требования: <br/>
- Таблица удовлетворяет 2НФ
- Нет зависимостей одних неключевых атрибутов от других (все атрибуты зависят от первичного ключа).

### CRUD oперации
#### INSERT — добавить строки в таблицу

INSERT добавляет строки в таблицу. Эта команда может добавить одну или несколько строк, сформированных выражениями значений, либо ноль или более строк, выданных дополнительным запросом.<br/>
Имена целевых столбцов могут перечисляться в любом порядке. Если список с именами столбцов отсутствует, по умолчанию целевыми столбцами становятся все столбцы заданной таблицы. Если выражение для любого столбца выдаёт другой тип данных, система попытается автоматически привести его к нужному.<br/><br/>

Примеры запросов: [07_insert.sql](04_DDL/07_insert.sql)

#### UPDATE — изменить строки таблицы

UPDATE изменяет значения указанных столбцов во всех строках, удовлетворяющих условию. В предложении SET должны указываться только те столбцы, которые будут изменены; столбцы, не изменяемые явно, сохраняют свои предыдущие значения.<br/><br/>
Изменить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя способами: применяя вложенные запросы или указав дополнительные таблицы в предложении FROM. Выбор предпочитаемого варианта зависит от конкретных обстоятельств.<br/><br/>

Примеры запросов: [08_update_delete_returning.sql](04_DDL/08_update_delete_returning.sql)

#### DELETE — удалить записи таблицы

Команда DELETE удаляет из указанной таблицы строки, удовлетворяющие условию WHERE. Если предложение WHERE отсутствует, она удаляет из таблицы все строки, в результате будет получена рабочая, но пустая таблица.<br/><br/>
Удалить строки в таблице, используя информацию из других таблиц в базе данных, можно двумя способами: применяя вложенные запросы или указав дополнительные таблицы в предложении USING.<br/><br/>
TRUNCATE реализует более быстрый механизм удаления всех строк из таблицы. **ИСПОЛЬЗОВАТЬ ТОЛЬКО ЕСЛИ НУЖНО ОЧИСТИТЬ ВСЮ ТАБЛИЦУ** <br/><br/>

Примеры запросов: [08_update_delete_returning.sql](04_DDL/08_update_delete_returning.sql)

#### RETURNING - получить модифицированные данные в процессе их обработки

Применение RETURNING позволяет обойтись без дополнительного запроса к базе для сбора данных и это особенно ценно, когда как-то иначе трудно получить изменённые строки надёжным образом.<br/><br/>
В предложении RETURNING допускается то же содержимое, что и в выходном списке команды SELECT. Оно может содержать имена столбцов целевой таблицы команды или значения выражений с этими столбцами. Также часто применяется краткая запись RETURNING *, выбирающая все столбцы целевой таблицы по порядку. 

## Представления Views
Представления можно использовать практически везде, где можно использовать обычные таблицы. И довольно часто представления создаются на базе других представлений. Представления позволяют скрыть внутреннее устройство таблиц, которые могут меняться по мере развития приложения, за надёжными интерфейсами. <br/><br/>
Активное использование представлений — это ключевой аспект хорошего проектирования баз данных SQL.<br/><br/>
CREATE VIEW создаёт представление запроса. Создаваемое представление лишено физической материализации, поэтому указанный запрос будет выполняться при каждом обращении к представлению.<br/><br/>
Особенности использования представлений - Views:
- View – сохранённый запрос в виде объекта БД (виртуальная таблица).
- К view можно делать обычный SELECT.
- Views можно соединять и делать всё что из обычными запросами. 
- Производительность такая де как и у обычной таблицы. 
- Позволяет сохранять сложные вопросы как view и делать запросы к ней.
- Позволяет подменить реальную таблицу (view это виртуальная таблица) 
- Позволяет создавать виртуальную таблицы соединяющую несколько таблиц, это нужно для того, чтобы клиент не мог определить реальную структуру данных. Это может снимать излишнюю смысловую нагрузку на клиенте.
- Позволяет скрыть логику агрегации данных при роботе через ORM
- Позволяет скрыть информацию (столбцы) от групп пользователей через фильтр.

При этом на представлении лежат несколько ограничей:
- Можно добавлять только новые столбцы 
- Нельзя удалять существующие.
- Нельзя поменять имена столбцов.
- Нельзя поменять даже порядок следования столбцов. 

В случае, когда нам нужно поменять что-то из того, что входит в ряд ограничений, необходимо будет пересоздать представление с помощью команды: <br/><br/>

CREATE OR REPLACE VIEW <view_name> AS <view_name> <br/><br/>

Новый запрос должен выдавать те же столбцы, что выдавал запрос, ранее определённый для этого представления (то есть, столбцы с такими же именами должны иметь те же типы данных и следовать в том же порядке), но может добавить несколько новых столбцов в конце списка. Вычисления, в результате которых формируются столбцы представления, могут быть совершенно другими. 

Синтаксис переименовывание представлений:

ALTER VIEW <old_view_name> RENAME TO <new_view_name>

Синтаксис удаления представлений:

DROP VIEW <view_name>
DROP VIEW IF EXISTS <view_name>

Представления можно модифицировать, но с явными ограничениями:
-	Только одна таблица в секции FROM
-	Нет DISTINCT, GROUP BY, HAVING, UNION, INTERSECT, EXCEPT, LIMIT
-	Нет скалярный функций, MIN, MAX, SUM, COUNT, AVG.
-	WHERE не под запретом.

Если нужны применить изменения с применением выше описанных ограничений, то представление необходимо будет удалить и заново её создать. 

Через представления View нельзя удалить те данные, которые есть в реальной таблице, но нет в представлении View.

Через представления View, мы можем вставлять данные противоречащие фильтру CHECK. Чтобы фильтр брался в учёт необходимо после условия  WHERE необходимо указать: WITH LOCAL CHECK OPTION:
```
CREATE OR REPLACE VIEW <view_name> AS 
SELECT <column_name>
FROM <table_name>
WHERE <condition>
WITH LOCAL CHECK OPTION
```
